<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LuckyTime Mines</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the game */
        body {
            font-family: 'Inter', sans-serif; /* Using Inter font as per instructions */
            background-color: #1a1a2e; /* Dark background similar to the image */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh; /* Ensure body takes full viewport height */
            margin: 0;
            color: #e0e0e0;
            overflow: hidden; /* Prevent scrolling on the body */
            padding: 0.5rem; /* Reduced padding to give more space */
        }

        .game-container {
            background-color: #2a2a4a; /* Darker blue/purple for the container */
            border-radius: 1rem; /* Rounded corners */
            padding: 0.5rem; /* Reduced padding for smaller cells */
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.4);
            text-align: center;
            width: 95%; /* Increased fluid width */
            max-width: 450px; /* Reduced max width for a smaller game */
            display: flex;
            flex-direction: column;
            gap: 0.75rem; /* Slightly reduced gap */
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.4rem 0.8rem; /* Slightly reduced padding */
            background-color: #3b3b5c;
            border-radius: 0.75rem;
            font-size: 0.9rem; /* Reduced font size for header info */
        }

        .game-title h1 {
            font-size: 1.8rem; /* Slightly reduced title font size */
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.4rem; /* Reduced space between cells */
            padding: 0.4rem; /* Reduced padding */
            background-color: #3b3b5c;
            border-radius: 0.75rem;
        }

        .cell {
            width: 100%;
            padding-bottom: 100%; /* Makes cells square */
            position: relative;
            background-color: #4a4a75;
            border-radius: 0.4rem; /* Slightly reduced border radius */
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.6rem; /* Reduced font size for cell content */
            font-weight: bold;
            color: #e0e0e0;
            transition: background-color 0.15s ease-in-out, transform 0.15s ease-in-out;
        }

        .cell.revealed {
            background-color: #1a1a2e;
            cursor: default;
        }

        .cell.safe {
            background-color: #0b3d02; /* Green for safe */
            color: #d4af37;
        }

        .cell.bomb {
            background-color: #e53e3e; /* Red for bomb */
            color: #fff;
        }

        .cell:active:not(.revealed) {
            transform: scale(0.95);
        }

        .cell span {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 0.6rem; /* Slightly reduced gap */
            padding: 0.5rem;
            background-color: #3b3b5c;
            border-radius: 0.75rem;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .input-group label {
            flex-shrink: 0;
            font-size: 0.85rem; /* Slightly reduced font size */
            color: #a0aec0;
        }

        .input-group input,
        .input-group select {
            flex-grow: 1;
            padding: 0.4rem; /* Reduced padding */
            border-radius: 0.25rem;
            border: 1px solid #4a4a75;
            background-color: #1a1a2e;
            color: #e0e0e0;
            font-size: 0.9rem; /* Reduced font size */
        }

        .input-group input[type="number"] {
            -moz-appearance: textfield; /* Firefox */
        }
        .input-group input::-webkit-outer-spin-button,
        .input-group input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .button-group {
            display: flex;
            gap: 0.6rem; /* Slightly reduced gap */
        }

        .btn {
            flex: 1;
            padding: 0.6rem; /* Reduced padding */
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            color: #fff;
            border: none;
            font-size: 0.95rem; /* Slightly reduced font size */
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-start {
            background-color: #4CAF50; /* Green */
        }
        .btn-start:hover:not(:disabled) {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        .btn-cashout {
            background-color: #008CBA; /* Blue */
        }
        .btn-cashout:hover:not(:disabled) {
            background-color: #007bb5;
            transform: translateY(-2px);
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: #2a2a4a;
            padding: 1.5rem; /* Reduced padding */
            border-radius: 0.75rem;
            text-align: center;
            box-shadow: 0 0.5rem 1.5rem rgba(0, 0, 0, 0.6);
            width: 90%;
            max-width: 350px; /* Reduced max-width */
            color: #e0e0e0;
            transform: translateY(-20px);
            transition: transform 0.3s ease-in-out;
        }

        .modal-overlay.active .modal-content {
            transform: translateY(0);
        }

        .modal-content h3 {
            font-size: 1.5rem; /* Reduced font size */
            margin-bottom: 0.6rem; /* Reduced margin */
            color: #d4af37; /* Gold accent */
        }

        .modal-content p {
            font-size: 1rem; /* Reduced font size */
            margin-bottom: 1.2rem; /* Reduced margin */
        }

        .modal-content button {
            background-color: #4CAF50;
            color: white;
            padding: 0.6rem 1.2rem; /* Reduced padding */
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 0.9rem; /* Reduced font size */
            font-weight: bold;
            transition: background-color 0.2s;
        }

        .modal-content button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <div class="balance-info">
                <span class="text-gray-400">Balance:</span>
                <span id="playerBalanceDisplay" class="font-bold text-green-400">â‚±0.00</span>
            </div>
            <div class="game-title">
                <h1 class="text-2xl font-bold text-yellow-400">Mines</h1>
            </div>
            <div class="winnings-info">
                <span class="text-gray-400">Winnings:</span>
                <span id="currentWinningsDisplay" class="font-bold text-yellow-300">â‚±0.00</span>
            </div>
        </div>

        <div class="grid-container" id="minesGrid">
            </div>

        <div class="controls">
            <div class="input-group">
                <label for="betAmountInput">Bet Amount:</label>
                <input type="number" id="betAmountInput" value="100" min="100" step="100">
            </div>
            <div class="input-group">
                <label for="numBombsSelect">Number of Bombs:</label>
                <select id="numBombsSelect">
                    <option value="3">3</option>
                    <option value="5">5</option>
                    <option value="7">7</option>
                    <option value="10">10</option>
                    <option value="15">15</option>
                    <option value="20">20</option>
                </select>
            </div>
            <div class="button-group">
                <button id="startGameBtn" class="btn btn-start">Start Game</button>
                <button id="cashoutBtn" class="btn btn-cashout" disabled>Cashout</button>
            </div>
        </div>
    </div>

    <div id="gameModal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="modalTitle"></h3>
            <p id="modalMessage"></p>
            <button id="modalCloseBtn">Play Again</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const playerBalanceDisplay = document.getElementById('playerBalanceDisplay');
            const currentWinningsDisplay = document.getElementById('currentWinningsDisplay');
            const minesGrid = document.getElementById('minesGrid');
            const betAmountInput = document.getElementById('betAmountInput');
            const numBombsSelect = document.getElementById('numBombsSelect');
            const startGameBtn = document.getElementById('startGameBtn');
            const cashoutBtn = document.getElementById('cashoutBtn');

            const gameModal = document.getElementById('gameModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalMessage = document.getElementById('modalMessage');
            const modalCloseBtn = document.getElementById('modalCloseBtn');

            let playerBalance = 0;
            let currentWinnings = 0;
            let currentMultiplier = 1; // Tracks multiplier for next safe tile
            let openedTilesCount = 0;
            let gameBoard = []; // Represents the 5x5 grid
            let totalBombs = 0;
            let gameInProgress = false;

            // Multipliers for mines (simplified example, in a real game these are pre-calculated for each number of bombs)
            // This would typically be a more complex calculation based on probability.
            const multipliers = {
                '3': [1.10, 1.25, 1.40, 1.60, 1.85, 2.15, 2.50, 2.90, 3.35, 3.85, 4.40, 5.00, 5.70, 6.50, 7.50, 8.60, 9.80, 11.20, 12.80, 14.60, 16.70, 19.00],
                '5': [1.15, 1.35, 1.55, 1.80, 2.10, 2.45, 2.85, 3.30, 3.80, 4.40, 5.05, 5.80, 6.65, 7.60, 8.70, 9.95, 11.40, 13.00, 14.80, 16.90],
                '7': [1.20, 1.45, 1.70, 2.00, 2.35, 2.75, 3.20, 3.75, 4.35, 5.05, 5.85, 6.80, 7.90, 9.15, 10.60, 12.30, 14.25, 16.50],
                '10': [1.30, 1.60, 1.95, 2.35, 2.85, 3.45, 4.15, 5.00, 6.00, 7.20, 8.60, 10.30, 12.30, 14.70, 17.60],
                '15': [1.45, 1.90, 2.45, 3.15, 4.05, 5.20, 6.70, 8.60, 11.00, 14.00],
                '20': [1.70, 2.35, 3.25, 4.50, 6.20, 8.50]
            };


            function showModal(title, message) {
                modalTitle.textContent = title;
                modalMessage.innerHTML = message; // Use innerHTML to allow for HTML tags
                gameModal.classList.add('active');
            }

            function hideModal() {
                gameModal.classList.remove('active');
            }

            // Function to fetch and update balance from server
            async function fetchAndUpdateBalance() {
                try {
                    const response = await fetch('update_balance.php', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ game: 'mines', action: 'get_balance' }),
                    });
                    const data = await response.json();
                    if (data.success) {
                        playerBalance = parseFloat(data.newBalance);
                        playerBalanceDisplay.textContent = `â‚±${playerBalance.toFixed(2)}`;
                    } else {
                        // Handle error fetching balance, maybe show a generic error or log it
                        console.error('Failed to fetch balance:', data.message);
                        // showModal('Error', `Failed to load balance: ${data.message}`); // This might be too disruptive
                    }
                } catch (error) {
                    console.error('Error fetching balance:', error);
                    // showModal('Error', `Network error fetching balance.`);
                }
            }

            // Function to send game action to server
            async function sendGameAction(action, dataToSend) {
                try {
                    const response = await fetch('update_balance.php', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ game: 'mines', action: action, ...dataToSend }),
                    });
                    const data = await response.json();
                    if (data.success) {
                        playerBalance = parseFloat(data.newBalance);
                        playerBalanceDisplay.textContent = `â‚±${playerBalance.toFixed(2)}`;
                        return data; // Return data for further client-side processing
                    } else {
                        showModal('Transaction Failed', data.message);
                        console.error('Server error:', data.message);
                        return null;
                    }
                } catch (error) {
                    showModal('Network Error', 'Could not connect to the server. Please check your internet connection.');
                    console.error('Fetch error:', error);
                    return null;
                }
            }


            function generateBoard() {
                gameBoard = [];
                const cells = 25; // 5x5 grid
                const bombPositions = new Set();
                while (bombPositions.size < totalBombs) {
                    bombPositions.add(Math.floor(Math.random() * cells));
                }

                for (let i = 0; i < cells; i++) {
                    gameBoard.push({
                        id: i,
                        hasBomb: bombPositions.has(i),
                        isRevealed: false
                    });
                }
            }

            function renderBoard() {
                minesGrid.innerHTML = '';
                gameBoard.forEach(cellData => {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.id = cellData.id;

                    if (gameInProgress && !cellData.isRevealed) {
                        cell.addEventListener('click', handleCellClick);
                    }

                    if (cellData.isRevealed) {
                        cell.classList.add('revealed');
                        cell.classList.add(cellData.hasBomb ? 'bomb' : 'safe');
                        cell.innerHTML = `<span>${cellData.hasBomb ? 'ðŸ’¥' : 'ðŸ’Ž'}</span>`;
                    }
                    minesGrid.appendChild(cell);
                });
            }

            function calculateCurrentWinnings() {
                const selectedMultipliers = multipliers[totalBombs.toString()];
                if (selectedMultipliers && openedTilesCount > 0 && openedTilesCount <= selectedMultipliers.length) {
                    currentMultiplier = selectedMultipliers[openedTilesCount - 1];
                } else if (openedTilesCount === 0) {
                    currentMultiplier = 1;
                } else {
                    currentMultiplier = 0; // Should not happen if data is well defined
                }
                currentWinnings = parseFloat(betAmountInput.value) * currentMultiplier;
                currentWinningsDisplay.textContent = `â‚±${currentWinnings.toFixed(2)}`;
            }

            async function handleCellClick(event) {
                if (!gameInProgress) return;

                const cellId = parseInt(event.target.dataset.id);
                const cellData = gameBoard[cellId];

                if (cellData.isRevealed) return; // Prevent re-clicking revealed cells

                cellData.isRevealed = true;
                event.target.classList.add('revealed');

                if (cellData.hasBomb) {
                    event.target.classList.add('bomb');
                    event.target.innerHTML = `<span>ðŸ’¥</span>`;
                    gameOver(false); // Player lost
                } else {
                    event.target.classList.add('safe');
                    event.target.innerHTML = `<span>ðŸ’Ž</span>`;
                    openedTilesCount++;
                    calculateCurrentWinnings();
                    cashoutBtn.disabled = false; // Enable cashout after first safe click

                    // Check for win condition (all non-bomb tiles opened)
                    if (openedTilesCount === (25 - totalBombs)) {
                        gameOver(true); // Player won by clearing all safe tiles
                    }
                }
                renderBoard(); // Re-render to update classes/listeners
            }

            async function startGame() {
                const betAmount = parseFloat(betAmountInput.value);
                totalBombs = parseInt(numBombsSelect.value);

                if (isNaN(betAmount) || betAmount <= 0) {
                    showModal('Invalid Bet', 'Please enter a valid bet amount.');
                    return;
                }

                if (betAmount > playerBalance) {
                    showModal('Insufficient Funds', `You only have â‚±${playerBalance.toFixed(2)}.`);
                    return;
                }

                // Send action to deduct bet
                const response = await sendGameAction('start_game', { betAmount: betAmount }); // CHANGED ACTION
                if (response) {
                    gameInProgress = true;
                    openedTilesCount = 0;
                    currentWinnings = 0;
                    currentMultiplier = 1;
                    currentWinningsDisplay.textContent = `â‚±${currentWinnings.toFixed(2)}`;
                    generateBoard();
                    renderBoard(); // Render initial board with unrevealed cells

                    startGameBtn.disabled = true;
                    betAmountInput.disabled = true;
                    numBombsSelect.disabled = true;
                    cashoutBtn.disabled = true; // Disabled until first safe click
                }
            }

            async function cashout() {
                if (!gameInProgress || currentWinnings <= 0) {
                    showModal('Invalid Cashout', 'Cannot cash out with no winnings or game not in progress.');
                    return;
                }

                // Send action to add winnings
                const response = await sendGameAction('cashout', { winningsAmount: currentWinnings }); // CHANGED ACTION
                if (response) {
                    gameOver(true); // Player cashed out successfully
                }
            }

            function gameOver(won) {
                gameInProgress = false;
                // Reveal all bombs if player lost
                if (!won) {
                    gameBoard.forEach(cellData => {
                        if (cellData.hasBomb && !cellData.isRevealed) {
                            cellData.isRevealed = true;
                        }
                    });
                }
                renderBoard(); // Re-render to show all bombs (if lost) or final state

                // Update final message and balance based on win/loss
                if (won) {
                    // Message already handled by sendGameAction response if successful cashout
                    // For winning by clearing all tiles, show a message here.
                    if (openedTilesCount === (25 - totalBombs)) {
                         showModal('Congratulations!', `You cleared all safe tiles and won â‚±${currentWinnings.toFixed(2)}!`);
                    } else {
                        // This case is for successful cashout
                        // The sendGameAction already showed modal for cashout success.
                        // We might not need another modal here, or just a simple one.
                    }
                } else {
                    currentWinnings = 0; // If lost, winnings are reset
                    currentWinningsDisplay.textContent = currentWinnings.toFixed(2);
                    showModal('Game Over!', `ðŸ’¥ BOOM! You hit a bomb.`);
                }

                // Re-enable start button and disable cashout
                updateStartButtonState(); // Use new function to set start button state
                cashoutBtn.disabled = true;
                betAmountInput.disabled = false;
                numBombsSelect.disabled = false;

                // After game over, always refresh balance to show current state, esp. for losses
                fetchAndUpdateBalance();
            }

            // Function to update start button state based on inputs
            function updateStartButtonState() {
                const betAmount = parseFloat(betAmountInput.value);
                startGameBtn.disabled = isNaN(betAmount) || betAmount <= 0 || gameInProgress;
            }


            // Event Listeners
            startGameBtn.addEventListener('click', startGame);
            cashoutBtn.addEventListener('click', cashout);

            modalCloseBtn.addEventListener('click', () => {
                hideModal();
                initializeGame(); // Prepare for a new game
            });

            betAmountInput.addEventListener('input', updateStartButtonState);
            numBombsSelect.addEventListener('change', updateStartButtonState);


            // Initial setup when the page loads
            function initializeGame() {
                gameInProgress = false;
                openedTilesCount = 0;
                currentWinnings = 0;
                currentMultiplier = 1;
                currentWinningsDisplay.textContent = `â‚±${currentWinnings.toFixed(2)}`;
                betAmountInput.value = 100; // Reset bet input
                numBombsSelect.value = 3; // Reset bomb count
                generateBoard(); // Generate a fresh board without revealing
                renderBoard(); // Render it unrevealed
                updateStartButtonState(); // Enable start button
                cashoutBtn.disabled = true;
                betAmountInput.disabled = false;
                numBombsSelect.disabled = false;
                fetchAndUpdateBalance(); // Get initial balance
            }

            initializeGame();
        });
    </script>
</body>
</html>